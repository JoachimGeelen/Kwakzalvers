<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kwakzalvers</title>
    <!-- Bulma CSS Framework -->
    <!-- <link href="https://cdn.jsdelivr.net/npm/bulma@0.9.3/css/bulma.min.css" rel="stylesheet"> -->
     <style>
        :root {
            --0-ingredient: rgb(209, 222, 222);
            --1-ingredient: #7aa82c;
            --2-ingredient: hsl(204, 46%, 55%);
            --3-ingredient: #ce523c;
            --4-ingredient: #e4bf16;
            --5-ingredient: #e58026;
            --6-ingredient: hsl(240, 10%, 55%);
            --7-ingredient: hsl(308, 32%, 55%);
        }
        .white {background-color: var(--0-ingredient);}
        .green {background-color: var(--1-ingredient);}
        .blue {background-color: var(--2-ingredient);}
        .red {background-color: var(--3-ingredient);}
        .yellow {background-color: var(--4-ingredient);}
        .orange {background-color: var(--5-ingredient);}
        .black {background-color: var(--6-ingredient);}
        .purple {background-color: var(--7-ingredient);}

        /* div { */
            /* outline: 1px solid red */
            /* box-shadow:0 0 0 1px red; */
        /* } */
        .bar {
            display: flex;
            justify-content: space-between;
            background-color: slategray;
        }
        .logo {
            height: 100px;
            width: auto;
        }
        .navigator {
            display: flex;
            flex-flow: row wrap;
            justify-content: flex-end;
            color: white;
            /* vertical-align: central; */
            /* background-color: slategray; */
            /* gap:10px */
        }
        .navigator a {
            /* text-decoration: none; */
            display: flex;
            justify-content: center;
            align-content: center;
            padding: 1em;
            cursor: pointer;
            background-color: darkslategray;
            /* vertical-align: central; */
            /* height: 100%; */
        }
        .ingredientList {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-content: flex-start;
        }
        .ingredient {
            text-align: center;
            align-content: center;
            height: 3em;
            width: 3em;
            margin: 0.1em;
        }
        .inventoryItem {
            cursor: pointer;
        }
        .colorButtonList {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-content: flex-start;
        }
        .colorButton {
            text-align: center;
            align-content: center;
            height: 5em;
            width: 5em;
            cursor: pointer;
        }
     </style>
</head>
<body>
    <!-- <h1 class="is-size-1 has-text-centered">Bag</h1> -->
    <header class="bar">
        <div>
            <img src="logo.webp" class="logo">
        </div>
        <div class="navigator">
            <a id="view-cauldron">Cauldron</a>
            <a id="view-store">Store</a>
        </div>
    </header>


    <div id="Cauldron">
        <div id="Bag">
        <h3 class="is-size-3">Bag</h3>
        <div>
            <!-- Button to pick a random ingredient -->
            <button onclick="pickIngredient()">Pick Random Ingredient</button>
            
            <!-- <button onclick="drawMultipleIngredients(4)">Draw 4 Ingredients</button> -->
            <button onclick="mydrawMultipleIngredients()">Draw Multiple</button>
            <button onclick="undoLastSelect()">Undo</button>
        </div>
        <div id="bag-ingredients" class="ingredientList"></div>
    </div>
    
    <div id="Board">
        <h3 class="is-size-3">Board</h3>
        <button onclick="resetBag()">Reset Bag</button>
            <div id="board-ingredients" class="ingredientList inventoryItem"></div>
        </div>
    </div>


    <div id="Store" style="display:none">
        <div id="Buy">
            <h3 class="is-size-3">Buy Ingredients</h3>
            <div id="buy-buttons">
                <div id="color-buttons" class="colorButtonList"></div>
                <div id="value-buttons" class="colorButtonList"></div>

            </div>
        </div>

        <div id="Owned">
            <!-- Section to display owned ingredients and bag contents -->
            <h3 class="is-size-3">Owned Ingredients</h3>
            <div id="owned-ingredients" class="ingredientList"></div>
        </div>
    </div>
</body>

<script>
    const Color = {
        WHITE: 'white',
        GREEN: 'green',
        BLUE: 'blue',
        RED: 'red',
        YELLOW: 'yellow',
        ORANGE: 'orange',
        BLACK: 'black',
        PURPLE: 'purple',
    };
    const ColorById = new Map();
    ColorById.set(0, Color.WHITE);
    ColorById.set(1, Color.GREEN);
    ColorById.set(2, Color.BLUE);
    ColorById.set(3, Color.RED);
    ColorById.set(4, Color.YELLOW);
    ColorById.set(5, Color.ORANGE);
    ColorById.set(6, Color.BLACK);
    ColorById.set(7, Color.PURPLE);

    const valuesByColorId = new Map();
    ColorById.forEach((color, colorId) => {
        if (color === Color.WHITE) {
            values = [1, 2, 3];
        } else if ([Color.GREEN, Color.BLUE, Color.RED, Color.YELLOW].includes(color)) {
            values = [1, 2, 4];
        } else {
            values = [1];
        }
        valuesByColorId.set(colorId, values);
    });

    

    class Ingredient {
        constructor(color, value) {
            this.color = color;
            this.value = value;
        }
    }

    function getIngredientId(colorId, value) {
        return colorId*10 + value;
    }

    function createAllIngredients() {
        const ingredients = new Map()
        ColorById.forEach((color, colorId) => {
            const values = valuesByColorId.get(colorId);
            values.forEach(value => {
                const ingredient = new Ingredient(colorId, value);
                let id = getIngredientId(colorId, value);
                ingredients.set(id, ingredient);
            });
        });
        return ingredients;
    }

    

    class Player {
        constructor() {
            this.ownedIngredients = {};  // Stores the total number of each ingredient owned
            this.bag = {};  // Tracks current ingredients in the bag
            this.board = []; // Stores all picked ingredients
        }

        purchase(id, quantity = 1) {
            if (!this.ownedIngredients[id]) {
                this.ownedIngredients[id] = 0;
            }
            this.ownedIngredients[id] += quantity;
            this.resetBag();
        }

        sell(id) {
            if (this.ownedIngredients[id] > 0) {
                this.ownedIngredients[id] -= 1;
                if (this.ownedIngredients[id] === 0) {
                    delete this.ownedIngredients[id];  // Remove key if count reaches 0
                }
                this.resetBag();
                return;
            }
            throw new Error("Attempting to sell an ingredient tha tis not owned!")
        }

        resetBoard() {
            this.board = [];
        }

        resetBag() {
            this.bag = { ...this.ownedIngredients };  // Reset bag to match owned ingredients
        }

        drawRandomIngredientId(bag) {
            const rawIngredientList = []
            Object.keys(bag).forEach(id => {
                const count = bag[id];
                for (let i=0; i<count; i++) {
                    rawIngredientList.push(id);
                }
            })
            const randomIndex = Math.floor(Math.random() * rawIngredientList.length);
            const randomIngredientId = rawIngredientList[randomIndex];
            bag[randomIngredientId]--;
            return randomIngredientId;
        }

        drawMultipleRandomIngredientIds(count) {
            const tempBag = structuredClone(this.bag);
            const selectedIngredientIds = [];
            for (let i=0; i<count; i++) {
                const ingredientId = this.drawRandomIngredientId(tempBag);
                selectedIngredientIds.push(ingredientId);
            }
            return selectedIngredientIds;
        }

        removeIngredientFromBag(bag, ingredientId) {
            bag[ingredientId]--;
        }

        placeIngredientOnBoard(ingredientId) {
            this.board.push(ingredientId);
        }

        playSingleAction() {
            const randomIngredientId = this.drawRandomIngredientId(this.bag);
            this.placeIngredientOnBoard(randomIngredientId);
            return randomIngredientId;
        }
        removeFromBoard(boardId) {
            if (this.board.length === 0) return;
            if (boardId < 0) throw new Error("bad board ID");
            const selectedIngredientId = this.board[boardId];
            this.board.splice(boardId, 1);
            this.bag[selectedIngredientId]++;
        }

        undoPlay() {
            if (this.board.length === 0) return;
            const lastIngredientId = this.board.pop();
            // console.log(lastIngredient)
            this.bag[lastIngredient]++;
        }
        show() {
            console.log("Bag: ", this.bag);
            console.log("board: ", this.board)
            // console.log("Owned Ingredients: ", this.ownedIngredients);
        }
    }


    function undoLastSelect() {
        // console.log(player.board)
        player.undoPlay();
        // console.log(player.board)
        updateUI();
    }

    function removeFromBoardWrapper(boardId) {
        if (confirm(`Remove ${ingredientIdToText(player.board[boardId])}?`)) {
            player.removeFromBoard(boardId);
            updateUI();
        }
    }



    // Game logic (Player, Ingredient, Color) stays the same as before


    // Create player instance
    
    function ingredientIdToText(ingredientId) {
        const ingredient = allIngredients.get(parseInt(ingredientId));
        // return `${ColorById.get(ingredient.color)} [${ingredient.value}]`;
        return `${ColorById.get(ingredient.color)}-${ingredient.value}`;
    }
    

    // Function to handle color selection for purchasing and show corresponding values
    function generateColorButtons() {
        const colorButtonsDiv = document.getElementById('color-buttons');
        colorButtonsDiv.innerHTML = '';
        ColorById.forEach((color, colorId) => {
            const colorButton = document.createElement('button');
            colorButton.textContent = color;
            colorButton.onclick = () => showValueButtons(colorId);
            colorButton.classList.add(color, "colorButton");

            colorButtonsDiv.appendChild(colorButton);
        });
    }
    function showValueButtons(colorId) {
        const valueButtonsDiv = document.getElementById('value-buttons');
        valueButtonsDiv.innerHTML = '';
        valuesByColorId.get(colorId).forEach(value => {
            const valueButton = document.createElement('button');
            valueButton.textContent = value;
            valueButton.onclick = () => buyIngredient(getIngredientId(colorId, value));
            valueButton.classList.add(ColorById.get(colorId), "colorButton");
            valueButtonsDiv.appendChild(valueButton);
        });
    }
    

    // Function to buy an ingredient
    function buyIngredient(ingredientId) {
        player.purchase(ingredientId);
        updateUI();  // Update the UI after purchase
    }

    // Function to remove an ingredient
    function sellIngredient(ingredientId) {
        if (confirm(`Sell ${ingredientIdToText(ingredientId)}?`)) {
            player.resetBag();

            if (navigator.vibrate) {
                navigator.vibrate(50);  // Vibrate for 200ms
            }
            player.sell(ingredientId);  // Calls the remove method in the Player class
            updateUI();  // Update the UI after removal
        }
    }

    // Function to pick a random ingredient
    function pickIngredient() {
        try {
            const ingredientId = player.drawRandomIngredientId(player.bag);
            player.placeIngredientOnBoard(ingredientId)
            // const ingredientId = player.playSingleAction()
            alert(ingredientIdToText(ingredientId));
            // const pickedId = player.pick();
            // alert(ingredientIdToText(pickedId));

        } catch (e) {
            alert(e.message);
        }
        updateUI();
    }
    

    
    
    function mydrawMultipleIngredients() {
        let size = 0;
        for (const ingredient in player.bag) {
            size += player.bag[ingredient];
        }

        message = "Bag size: " + size
        const answer = prompt(message, "1");
        if (!answer) return;
        const count = parseInt(answer);
        if (isNaN(count) || count < 0 || count > size) {
            alert("Invalid choice");
            return;
        }
        console.log(count)
        if (count === 0) return;

        const randomIngredientIds = player.drawMultipleRandomIngredientIds(count);
        const selectedIngredientId = promptUserToSelectIngredientId(randomIngredientIds);
        if (!selectedIngredientId) return;
        player.removeIngredientFromBag(player.bag, selectedIngredientId);
        player.placeIngredientOnBoard(selectedIngredientId);

        alert(ingredientIdToText(selectedIngredientId));
        updateUI();
    }
    function promptUserToSelectIngredientId(ingredientIds) {
        console.log(ingredientIds)
        let message = "You drew the following ingredients:\n";
        for (let i=0;i<ingredientIds.length;i++) {
            message += `${i+1}) ${ingredientIdToText(ingredientIds[i])}\n`;
        }
        // ingredientIds.forEach(id => {
        //     message += `${ingredientIdToText(id)}\n`;
        // });
        // message += "\nEnter the number of the ingredient you'd like to keep, or 0 to return all.";

        const answer = prompt(message, "0");
        if (!answer) choice = 0;
        else choice = parseInt(answer);
        
        if (isNaN(choice) || choice < 0 || choice > ingredientIds.length) {
            alert("Invalid choice");
            // Ask again with same selection
            promptUserToSelectIngredientId(ingredientIds);
        }
        if (choice === 0) {
            console.log(choice)
            // alert("Nothing picked");
            return;
        }
        return ingredientIds[choice-1];
    }


    // Function to reset the bag (put all owned ingredients back into the bag)
    function resetBag() {
        if (confirm("Are you sure you want to reset the bag? All picked ingredients will be returned.")) {
            player.resetBoard();  // Reset the bag by putting all owned ingredients back
            player.resetBag();
            updateUI();  // Update the UI after resetting

            if (navigator.vibrate) {
                navigator.vibrate(100);  // Vibrate for 200ms
            }
        }
    }

    // Function to update the UI
    function updateUI() {
        updateBoardUI();
        updateBagUI();
        updateOwnedIngredientsUI();
    }
    function updateBoardUI() {
        const boardDiv = document.getElementById('board-ingredients');
        boardDiv.innerHTML = '';
        player.board.forEach((ingredientId, boardId) => {
            const div = document.createElement("div");
            const ingredient = allIngredients.get(parseInt(ingredientId))
            div.innerHTML = ingredient.value;
            const color = ColorById.get(ingredient.color);
            div.classList.add(color, "ingredient");
            div.addEventListener('click', function (event) {
                removeFromBoardWrapper(boardId);
            });
            boardDiv.append(div);
        });
    }
    function updateBagUI(useStacks=false) {
        const bagDiv = document.getElementById('bag-ingredients');
        bagDiv.innerHTML = '';
        if (useStacks) {
            Object.keys(player.bag).forEach(ingredientId => {
                count = player.bag[ingredientId];
                if (count > 0) {
                    const div = document.createElement("div");
                    div.innerHTML = `x${count} ${ingredientIdToText(ingredientId)}`;
                    bagDiv.append(div);
                }
            });
        } else {
            Object.keys(player.bag).forEach(ingredientId => {
                for (let i=0; i<player.bag[ingredientId]; i++) {
                    const div = document.createElement("div");
                    const ingredient = allIngredients.get(parseInt(ingredientId))
                    div.innerHTML = ingredient.value;
                    const color = ColorById.get(ingredient.color);
                    div.classList.add(color, "ingredient");
                    bagDiv.append(div);
                }
            })
        }
    }
    function updateOwnedIngredientsUI(useStacks=false) {
        const ownedIngredientsDiv = document.getElementById('owned-ingredients');
        ownedIngredientsDiv.innerHTML = '';
        if (useStacks) {
            Object.keys(player.ownedIngredients).forEach(ingredientId => {
                count = player.ownedIngredients[ingredientId];
                if (count > 0) {
                    const div = document.createElement("div");
                    const ingredient = allIngredients.get(parseInt(ingredientId));
                    div.innerHTML = `x${count} ${ingredientIdToText(ingredientId)}`;
                    div.classList.add('inventoryItem');
                    const color = ColorById.get(ingredient.color);
                    div.classList.add(color);
                    div.addEventListener('click', function (event) {
                        sellIngredient(ingredientId);
                    });
                    ownedIngredientsDiv.append(div);
                }
            });
        } else {
            Object.keys(player.ownedIngredients).forEach(ingredientId => {
                for (let i=0; i<player.ownedIngredients[ingredientId]; i++) {
                    const div = document.createElement("div");
                    const ingredient = allIngredients.get(parseInt(ingredientId));
                    div.innerHTML = ingredient.value;
                    div.classList.add('inventoryItem');
                    const color = ColorById.get(allIngredients.get(parseInt(ingredientId)).color);
                    div.classList.add(color, "ingredient");
                    div.addEventListener('click', function (event) {
                        sellIngredient(ingredientId);
                    });
                    ownedIngredientsDiv.append(div);
                }
            })
        }
    }


    function startingPosition() {
        player.purchase(1, 4)
        player.purchase(2, 2)
        player.purchase(3, 1)
        player.purchase(11)
        player.purchase(51)
    }


    

    const player = new Player();
    const allIngredients = createAllIngredients();
    
    // UI STUFF
    // Get references to the divs
    const cauldronDiv = document.getElementById('Cauldron');
    const storeDiv = document.getElementById('Store');
    
    // Get references to the navigation links
    const viewCookingLink = document.getElementById('view-cauldron');
    const viewStoreLink = document.getElementById('view-store');
    
    // Add event listeners to toggle visibility
    viewCookingLink.addEventListener('click', function(event) {
        event.preventDefault();
        cauldronDiv.style.display = 'block';
        storeDiv.style.display = 'none';
    });
    
    viewStoreLink.addEventListener('click', function(event) {
        event.preventDefault();
        cauldronDiv.style.display = 'none';
        storeDiv.style.display = 'block';
    });
    generateColorButtons();
    



    
    startingPosition()
    updateUI();  // Initial call to display empty states
</script>
</html>
